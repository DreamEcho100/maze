# Supported [Zod](https://zod.dev/api) Types

## `z.coerce`

When using `z.coerce.*` types, the resolver will attempt to coerce input values to the expected type before validation.

useful for HTML inputs which always return strings. like:
- `z.coerce.number()` will convert "123" to 123 before validating as a number.
- `z.coerce.date()` will convert "2023-10-05" to a Date object before validating as a date.
- `z.coerce.boolean()` will convert "true"/"false" strings to boolean values.
- `z.coerce.bigint()` will convert numeric strings to BigInt values.
- `z.coerce.string()` will convert non-string values to strings using `String(value)`.

**NOTE:** Coercion may fail or produce unexpected results for some inputs. Always validate the final value against your schema.
**TODO:** maybe add a highlevel `smartCoerce` option to handle common cases like empty strings to undefined/null for optional fields? it could a boolean or a function `(value, fieldNode) => any` to allow custom coercion logic.
 
## `ZodString`

### Supported `ZodString` Validations

Basic Validations:
```ts
z.string().maxLength(5); // alias .max(5)
z.string().minLength(5); // alias .min(5)
z.string().length(5); // exact length, alias .min(5).max(5)
z.string().regex(/^[a-z]+$/);
```

Format Validations:
```ts
z.email();
z.uuid();
z.url();
z.httpUrl();       // http or https URLs only
z.hostname();
z.emoji();         // validates a single emoji character
z.base64();
z.base64url();
z.hex();
z.jwt();
z.nanoid();
z.cuid();
z.cuid2();
z.ulid();
z.ipv4();
z.ipv6();
z.cidrv4();        // ipv4 CIDR block
z.cidrv6();        // ipv6 CIDR block
z.hash("sha256");  // or "sha1", "sha384", "sha512", "md5"
z.iso.date();
z.iso.time();
z.iso.datetime();
z.iso.duration();
z.iso.currencyCode();
```

**TODO:** maybe save the `schema.def.format` string for further use?

### Supported on validation CB only:

The following validations are not supported in HTML attributes mapping, but can be handled in the validation callback:

```ts
z.string().startsWith("aaa");
z.string().endsWith("zzz");
z.string().includes("---");
z.string().uppercase();
z.string().lowercase();
```

**TODO:** how to handle `def.checks[number]._zod.def.check === "overwrite"` for custom validations?

```ts
z.string().trim(); // trim whitespace
z.string().toLowerCase(); // toLowerCase
z.string().toUpperCase(); // toUpperCase
z.string().normalize(); // normalize unicode characters
```

## `ZodNumber`

**NOTE:** beware of `Infinity` and `NaN` values in number fields. HTML number inputs will return empty string for these, which may cause issues if your schema does not allow empty strings.

### Supported `ZodNumber` Validations

Basic Validations:
```ts
    z.number().gt(5),
    z.number().gte(5),                     // alias .min(5)
    z.number().lt(5),
    z.number().lte(5),                     // alias .max(5)
    z.number().positive(),
    z.number().nonnegative(),
    z.number().negative(),
    z.number().nonpositive(),
    z.number().multipleOf(5),              // alias .step(5)
```

Integer Validations:
```ts
z.int();     // restricts to safe integer range
z.int32();   // restrict to int32 range
```

## `ZodBigInt`

### Supported `ZodBigInt` Validations

```ts
z.bigint().gt(5n);
z.bigint().gte(5n);                    // alias `.min(5n)`
z.bigint().lt(5n);
z.bigint().lte(5n);                    // alias `.max(5n)`
z.bigint().positive(); 
z.bigint().nonnegative(); 
z.bigint().negative(); 
z.bigint().nonpositive(); 
z.bigint().multipleOf(5n);             // alias `.step(5n)`
```

## `ZodBoolean`

**NOTE:** HTML checkboxes return `true` or `false`, but if unchecked they may not submit a value at all. Make sure your form handling accounts for this (e.g., default to `false` if no value is present).

### Supported `ZodBoolean` Validations

```ts
z.boolean();
```

## `ZodDate`

**NOTE:** HTML date inputs return date strings (e.g., "2023-10-05"). You will need to parse these strings into `Date` objects before validation, as Zod expects actual `Date` instances.

### Supported `ZodDate` Validations

```ts
z.date().min(new Date("2020-01-01"));
z.date().max(new Date("2025-12-31"));
```

## `ZodEnum`

**NOTE:** It will be considered as a string field with a combined regex of all enum values for HTML attributes mapping.

### Supported `ZodEnum` Validations

```ts
z.enum(["red", "green", "blue"]);
```

## `ZodLiteral` [string, number, boolean]

**NOTE:** It will be considered as a string/number/boolean field based on the literal type for HTML attributes mapping.

### Supported `ZodLiteral` Validations

```ts
z.literal("fixedValue");
z.literal(42);
z.literal(true);
```

**TODO:** the current implementation only account it as a string field. need to handle number and boolean literals too.

## `ZodFile`

**NOTE:** HTML file inputs return `FileList` objects. You will need to extract the individual `File` objects from the `FileList` before validation, as Zod expects actual `File` instances.

### Supported `ZodFile` Validations

```ts
const fileSchema = z.file();
 
fileSchema.min(10_000); // minimum .size (bytes)
fileSchema.max(1_000_000); // maximum .size (bytes)
fileSchema.mime("image/png"); // MIME type
fileSchema.mime(["image/png", "image/jpeg"]); // multiple MIME types
```

## `ZodOptional`, `ZodNullable`, `ZodNonOptional`, `ZodNullish`

These are unwrapped and used to set the `presence` property on the field node config.

presence values:
- "required" - for non-optional, non-nullable fields
- "optional" - for optional fields
- "nullable" - for nullable fields
- "nullish" - for nullish fields (optional + nullable)


## `ZodDefault`, `ZodPrefault`

These are unwrapped and used to set the `defaultValue` property on the field node config.

`ZodDefault` overrides `ZodOptional` to make the field effectively required with a default value.

While `ZodPrefault` keeps the field optional but provides a default value if none is supplied.

## `ZodReadonly`

These are unwrapped and used to set the `readOnly` property on the field node config.


## ZodUnknown, ZodAny, ZodNever

**NOTE:** These types are treated as "unknown" fields with no specific validations or HTML attributes mapping.

```ts
z.unknown();
z.any();
z.never();
```

**TODO:** The implementation currently is not accurate in some instances, need to fix it.

## `ZodObjects`

### Supported `ZodObjects` Validations

```ts
z.object({
    name: z.string().min(2).max(50),
    age: z.number().min(0).max(120),
    email: z.string().email(),
    isAdmin: z.boolean().optional(),
});
```

**TODO:** need to test [`z.strictObject`](https://zod.dev/api?id=zstrictobject), [z.looseObject](https://zod.dev/api?id=zlooseobject), `.catchall()`, `.extend()`, `.safeExtend()`, `.safeExtend()`, `.pick()`, `.omit()`, `.partial()`, `.required()`

**NOTE:** the properties of the object are lazily resolved when accessed _(via a Object.defineProperty getter and set on first access)_. This avoids infinite recursion for **recursive schemas**, but means that the full structure is not available upfront. So beware of this when trying to inspect the full schema structure immediately after resolution (e.g., using `Object.keys()` or similar).
**TODO:** maybe add an option to eagerly resolve the full structure after initial resolution?

## `ZodArray`

### Supported `ZodArray` Validations

```ts
z.array(z.string()).min(5); // must contain 5 or more items
z.array(z.string()).max(5); // must contain 5 or fewer items
z.array(z.string()).length(5); // must contain 5 items exactly
```

**Note:** The items can still be accessed via a dot notation like `myArrayField.0`, `myArrayField.1`, etc., and also via the special token `fieldNodeTokenEnum.arrayItem` to represent any item in the array. This allows for validating individual items or all items in the array.
**TODO:**: a dot notation like `myArrayField.0` vs `myArrayField[0]`, `fieldNodeTokenEnum.arrayItem` vs `myArrayField[]` vs `myArrayField[number]`? what's more intuitive?

## `ZodTuple`

The items can be accessed via their index like `myTupleField.0`, `myTupleField.1`, etc. Each index corresponds to the schema defined in the tuple. This allows for validating each item in the tuple individually. so **no special token is needed like for arrays**.

### Supported `ZodTuple` Validations

```ts
z.tuple([z.string(), z.number(), z.boolean()]); // fixed length tuple
z.tuple([z.object({ id: z.string() }), z.number()]) // tuple with object and number
```

## `ZodUnion`

The union options are represented by either a direct access or through the indexed union option through the token

On the following example:

```ts
z.union([
    z.object({ type: z.literal("A"), value: z.string() }),
    z.object({ type: z.literal("B"), value: z.number() }),
    z.object({ type: z.literal("C"), value: z.boolean() }),
])
```

The union options are represented by either:
- **direct access**: This will try to merge the path as much as possible
    - `fields.shape.type`: of `string` field type.
    - `fields.shape.value`: of `never` field type - since it's a combination of different types.
- **Indexed union option through the token**:
    - for the first union option
        - `fields.shape.${fieldNodeTokenEnum.unionOptionOn}[0].type`: of `string` field type.
        - `fields.shape.${fieldNodeTokenEnum.unionOptionOn}[0].value`: of `string` field type.
    - for the second union option
        - `fields.shape.${fieldNodeTokenEnum.unionOptionOn}[1].type`: of `string` field type.
        - `fields.shape.${fieldNodeTokenEnum.unionOptionOn}[1].value`: of `number` field type.
    - for the first union option
        - `fields.shape.${fieldNodeTokenEnum.unionOptionOn}[2].type`: of `string` field type.
        - `fields.shape.${fieldNodeTokenEnum.unionOptionOn}[2].value`: of `boolean` field type.

## `ZodDiscriminatedUnion`

It's the same as unions, except that on the field node config constraint, there is a `tag` property which can be used for determining the correct option based on the 

NOTE: It only works on **objects**

```ts
tag: {
  key: string, // the key that used as a discriminators on the unions
  values: new Set(),
  valueToOptionIndex: new Map(),
}
```

For example in

```ts
z.discriminatedUnion('type', [
    z.object({ type: z.literal("A"), value: z.string() }),
    z.object({ type: z.literal("B"), value: z.number() }),
    z.object({ type: z.literal("C"), value: z.boolean() }),
])
```

`fields.shape[fnConfigKey].tag` will be

```ts
{
  // The key used to define which current union option should be active
  // NOTE: This isn't the key path!!!
  // TODO: add a `keyPathSegments` and `keyPathString`
  key: 'type',
  // The possible values of the `key`
  values: new Set<'A'|'B'|'C'>
  // The `valueToOptionIndex.get` is **TS** overridden to get the correct outcome based on the value of the key
  // So it should:
  // - `.get('A')`: `0`
  // - `.get('B')`: `1`
  // - `.get('C')`: `2`
  valueToOptionIndex: new Map(),
}
```


## Supported but docs in progress 😅
Intersections
Records
Pipes
Transforms
.transform()
.preprocess()


## Notes

### Lazy evaluation

if a path is a descendant of a `ZodLazy` or the user/dev passed `isLazyEvaluated: true`

then:


- Object properties are lazy
- Array items are lazy
- Tuple items are lazy
- Record values are lazy
- Union options are lazy

Each lazy access is a property/child evaluation.


This avoids infinite recursion for recursive schemas, but means that the full structure is not available upfront. So beware of this when trying to inspect the full schema structure immediately after resolution (e.g., using `Object.keys()` or similar).

```ts
const categorySchema = z.lazy(() => z.object({
  id: z.string(),
  name: z.string(), 
  children: z.array(categorySchema) // ← Self-reference
}));
```

Your actual flow:

1. zodResolverImpl(categorySchema) 
2. → ZodLazy: calls schema.def.getter() → gets z.object({...})
3. → ZodObject: creates node with lazy properties via createDeferredProperty
4. → children property is NOT processed yet (lazy)
5. → User accesses node.children → lazy getter triggers
6. → ZodArray: creates node with lazy arrayItem via createDeferredProperty  
7. → arrayItem is NOT processed yet (lazy)
8. → User accesses node.children[arrayItem] → lazy getter triggers
9. → Back to step 1, but now it's a property access, not schema recursion

So accessing `fields.shape.children[0].name` on a lazy schema will trigger 3 property evaluations for the following field nodes:

1. `children` - evaluates the `ZodLazy` and then the `ZodArray`
2. `children[0]` - evaluates the `ZodArray` item
3. `children[0].name` - evaluates the `ZodObject` property

### Intersection merging conflicts

When merging two intersected schemas, if there are conflicting types for the same path, the resulting field node config will be set to `level: "never"` to indicate that no valid value can satisfy both schemas.

For example, intersecting a string and a number for the same path will result in a "never" type node.

```ts
z.intersection(
  z.object({ field: z.string() }),
  z.object({ field: z.number() })
)
```

This will produce a field node for `field` with:

```ts
{
  level: "never",
  type: "unknown",
  // ... rest of config
}
```

This is a safe fallback to prevent invalid states, but you may want to handle this case explicitly in your application logic.

### Cycle detection

When resolving schemas with `ZodLazy`, cycles can occur if a lazy schema references itself directly or indirectly. To prevent infinite recursion, a `WeakSet` is used to track schemas currently being resolved.

If a schema is encountered that is already in the `WeakSet`, it indicates a cycle, and the resolution for that path stops, returning a basic "unknown" field node.

This ensures that recursive structures can be represented without causing stack overflows or infinite loops.

### HTML attributes mapping limitations

Some Zod validations do not have direct equivalents in HTML attributes, so they cannot be represented in the field node config. These include:
- `z.string()` refinements like `.startsWith()`, `.endsWith()`, `.includes()`, `.uppercase()`, `.lowercase()`, etc.
- Custom regex patterns beyond basic format checks.
- `z.bigint()` validations, as HTML does not support bigint inputs, it won't be accurately represented since HTML number inputs are limited to safe integers.
- `z.date()` validations, as HTML date inputs return strings, not Date objects.
- `z.enum()` and `z.literal()` are simplified to basic string fields with regex patterns.
- Complex nested structures in `z.object()`, `z.array()`, `z.tuple()`, `z.union()`, and `z.discriminatedUnion()` are represented, but specific validations within them may not be fully captured.
- `z.intersection()` conflicts are resolved to "never" types, losing specific validation details.
These limitations mean that while the resolver captures the overall structure and basic validations of the schema, some specific rules may need to be enforced separately in your application logic or validation callbacks.
